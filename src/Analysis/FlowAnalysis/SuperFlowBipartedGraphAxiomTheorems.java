package Analysis.FlowAnalysis;

import Utils.HIPR.ParseHIPRFlowOutput;
import Utils.HIPR.ParseHIPRInputfile;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.TreeMap;
import java.util.stream.Collectors;

/**
 *
 * @author Reuel
 */
public class SuperFlowBipartedGraphAxiomTheorems {

    public static void main(String[] args) throws FileNotFoundException {

        /**
         * Parse the input graph file of HIPR.
         */
        File hiprInputFile = new File("biparted-graph-super-axiom-theorem.txt");
        ParseHIPRInputfile hiprInput = new ParseHIPRInputfile(hiprInputFile);
        hiprInput.parse();

        /**
         * Parse the output generated by HIPR after analyzing the above file.
         */
        File hiprOutputFile = new File("biparted-graph-super-axiom-theorem_maxflow.txt");
        ParseHIPRFlowOutput hiprOutput = new ParseHIPRFlowOutput(hiprOutputFile);
        hiprOutput.parse();

        int nodesCount = hiprInput.getNodesCount();
        int S = hiprInput.getS();

        Map<Integer, List<String>> paths = new TreeMap<>();

        /**
         * The u vertices are located in the first component of the biparted
         * graph and they link directly to the v vertices on the other partition
         * of the graph.
         */
        for (int startingU = 0, pathCount = 0; startingU <= nodesCount; startingU++) {

            //verify if S has and outgoing edge to the actual node
            if (hiprOutput.getArcFlow(S, startingU) <= 0) {
                continue;
            }

            pathCount++;

            List<String> actualPath = new ArrayList<>();
            paths.put(pathCount, actualPath);

            //An edge has been found from S to some node
            for (int u = startingU, v = 0; v <= nodesCount; v++) {

                if (hiprOutput.getArcFlow(u, v) > 0) {
                    String uName = hiprInput.getNodeName(u);
                    String vName = hiprInput.getNodeName(v);

                    actualPath.add(uName);

                    if (vName.equals("T") || !vName.endsWith("'")) {
                        throw new RuntimeException("Some possible inconsistency has been found.\nDestin node is " + vName);
                    }

                    String nextUName = vName.substring(0, vName.length() - 1);
                    int nextU = hiprInput.getNodeId(nextUName);

                    if (nextU == -1) {
                        break; //'Tis the end of the actual path
                    }

                    u = nextU;
                    v = -1; //It will become 0 at the next iteration
                }
            }
        }

        System.out.println("===========================================");

        System.out.println("Greatest path:");
        Optional<Entry<Integer, List<String>>> foundPath = paths.entrySet().stream()
                .collect(
                        Collectors.maxBy(Comparator.comparingInt((Entry<Integer, List<String>> e) -> {
                            return e.getValue().size();
                        }))
                );
        Entry<Integer, List<String>> greatestPath = foundPath.get();
        System.out.println(greatestPath);

        System.out.println("\n===========================================");
        System.out.println("Histogram:\n");
        Map<Integer, Integer> histogram = new TreeMap<>();

        paths.entrySet().stream()
                .forEach((Map.Entry<Integer, List<String>> entry) -> {
                    List<String> path = entry.getValue();
                    final int pathSize = path.size();

                    histogram.putIfAbsent(pathSize, 0);

                    int count = histogram.get(pathSize);
                    count++;
                    histogram.put(pathSize, count);

                });

        Optional<Entry<Integer, Integer>> largestHistogramFoundEntry = histogram.entrySet().stream()
                .collect(
                        Collectors.maxBy(Comparator.comparingInt((Entry<Integer, Integer> e) -> {
                            return e.getValue();
                        }))
                );
        Integer largestHistogramValue = largestHistogramFoundEntry.get().getValue();

        histogram.entrySet().stream().forEach((entry) -> {
            Integer key = entry.getKey();
            Integer value = entry.getValue();

            String column = "";

            for (int i = 0; i < ((double) value / largestHistogramValue) * 50.0; i++) {
                column = column.concat("#");
            }
            System.out.printf("%02d : % 5d %s\n", key, value, column);
        });

        Integer pathsSum = histogram.entrySet()
                .stream()
                .collect(Collectors.summingInt(Entry<Integer, Integer>::getValue));

        System.out.println("Total of paths: " + pathsSum);
        int minus = hiprOutput.getNodesCount() - (int) hiprOutput.getMaxFlow();

        System.out.println("Nodes - Flow: " + minus);

        int compare = Integer.compare(pathsSum, minus);

        if (compare == 0) {
            System.out.println("The paths are consistent");
        } else if (compare < 0) {
            System.out.printf("The paths are inconsistent (%d)\n", compare);
        } else {
            System.out.printf("The paths are inconsistent (%d)\n", compare);
        }
    }
}
