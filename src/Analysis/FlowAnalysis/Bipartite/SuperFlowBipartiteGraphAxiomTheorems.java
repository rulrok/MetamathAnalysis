package Analysis.FlowAnalysis.Bipartite;

import Utils.HIPR.ParseHIPRFlowOutput;
import Utils.HIPR.ParseHIPRInputfile;
import Utils.HistogramUtils;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.TreeMap;
import java.util.stream.Collectors;

/**
 *
 * @author Reuel
 */
public class SuperFlowBipartiteGraphAxiomTheorems {

    public static void main(String[] args) throws FileNotFoundException, IOException {

        /**
         * Parse the input graph file of HIPR.
         */
        File hiprInputFile = new File("biparted-graph-super-axiom-theorem-nomeredith.txt");
        ParseHIPRInputfile hiprInput = new ParseHIPRInputfile(hiprInputFile);
        hiprInput.parse();

        /**
         * Parse the output generated by HIPR after analyzing the above file.
         */
        File hiprOutputFile = new File("biparted-graph-super-axiom-theorem-nomeredith_maxflow.txt");
        ParseHIPRFlowOutput hiprOutput = new ParseHIPRFlowOutput(hiprOutputFile);
        hiprOutput.parse();

        int nodesCount = hiprInput.getNodesCount();
        int S = hiprInput.getS();

        Map<Integer, List<String>> paths = new TreeMap<>();
        Map<Integer, List<String>> reversePaths = new TreeMap<>();

        /**
         * The u vertices are located in the first component of the biparted
         * graph and they link directly to the v vertices on the other partition
         * of the graph.
         */
        for (int startingU = 0, pathCount = 0; startingU <= nodesCount; startingU++) {

            //verify if S has and outgoing edge to the actual node
            if (hiprOutput.getArcFlow(S, startingU) <= 0) {
                continue;
            }

            String startingUName = hiprInput.getNodeName(startingU);
            if (startingUName.endsWith("'")) {
                throw new RuntimeException(startingUName);
            }

            pathCount++;

            List<String> actualPath = new ArrayList<>();
            paths.put(pathCount, actualPath);

            //An edge has been found from S to some node
            for (int u = startingU, v = 0; v <= nodesCount; v++) {

                if (hiprOutput.getArcFlow(u, v) > 0) {
                    String uName = hiprInput.getNodeName(u);
                    String vName = hiprInput.getNodeName(v);

                    actualPath.add(uName);

                    if (vName.equals("T") || !vName.endsWith("'")) {
                        throw new RuntimeException("Some possible inconsistency has been found.\nDestin node is " + vName);
                    }

                    String nextUName = vName.substring(0, vName.length() - 1);
                    int nextU = hiprInput.getNodeId(nextUName);

                    if (nextU == -1) {
                        break; //'Tis the end of the actual path
                    }

                    u = nextU;
                    v = -1; //It will become 0 at the next iteration
                }
            }
        }

        /**
         * The ideia is similar to the above loop, but here the reverse path it
         * taken.
         */
        for (int i1 = 1, pathCount = 0; i1 <= nodesCount; i1++) {
            final double arcFlow = hiprOutput.getArcFlow(S, i1);

            //verify if S has and outgoing edge to the actual node
            if (i1 == S || arcFlow != 0) {
                continue;
            }

            String i1Name = hiprInput.getNodeName(i1);
            if (i1Name.endsWith("'") || i1Name.equals("T")) {
                continue;
            }

            pathCount++;

            List<String> actualPath = new ArrayList<>();
            reversePaths.put(pathCount, actualPath);

            actualPath.add(i1Name);

            String i2Name = i1Name.concat("'");
            int i2 = hiprInput.getNodeId(i2Name);

            //An edge has been found from S to some node
            for (int j1 = 0; j1 <= nodesCount; j1++) {

                if (hiprOutput.getArcFlow(j1, i2) == 1) {

                    String j1Name = hiprInput.getNodeName(j1);
                    if (j1Name.equals("S") || j1Name.endsWith("'")) {
                        throw new RuntimeException("Some possible inconsistency has been found.\nDestin node is " + j1Name);
                    } else {
                        actualPath.add(j1Name);
                    }

                    String nextI2Name = j1Name.concat("'");
                    int nextI2 = hiprInput.getNodeId(nextI2Name);

                    if (nextI2 == -1) {
                        break; //'Tis the end of the actual path
                    }

                    j1 = -1;
                    i2 = nextI2; //It will become 0 at the next iteration
                }
            }
        }

        System.out.println("===========================================");

        File pathOutput = new File("path.txt");
        try (FileWriter fileWriter = new FileWriter(pathOutput)) {
            Iterator<Entry<Integer, List<String>>> iterator = paths.entrySet()
                    .stream()
                    .sorted(
                            Comparator.comparingInt((Entry<Integer, List<String>> t) -> {
                                return t.getValue().size();
                            })
                    ).iterator();
            while (iterator.hasNext()) {
                Entry<Integer, List<String>> e = iterator.next();

                fileWriter.append(e.toString());
                fileWriter.append("\r\n");
            }
        }

        File pathReverseOutput = new File("path_reverse.txt");
        try (FileWriter fileWriter = new FileWriter(pathReverseOutput)) {
            Iterator<Entry<Integer, List<String>>> iterator = reversePaths.entrySet()
                    .stream()
                    .sorted(
                            Comparator.comparingInt((Entry<Integer, List<String>> t) -> {
                                return t.getValue().size();
                            })
                    ).iterator();
            while (iterator.hasNext()) {
                Entry<Integer, List<String>> e = iterator.next();

                fileWriter.append(e.toString());
                fileWriter.append("\r\n");
            }
        }

        System.out.println("Greatest path:");
        Optional<Entry<Integer, List<String>>> foundPath = paths
                .entrySet()
                .stream()
                .collect(
                        Collectors.maxBy(Comparator.comparingInt((Entry<Integer, List<String>> e) -> {
                            return e.getValue().size();
                        }))
                );
        Entry<Integer, List<String>> greatestPath = foundPath.get();
        System.out.println(greatestPath);

        System.out.println("\n===========================================");

        System.out.println("Greatest reverse path:");
        Optional<Entry<Integer, List<String>>> foundReversePath = reversePaths
                .entrySet()
                .stream()
                .collect(
                        Collectors.maxBy(Comparator.comparingInt((Entry<Integer, List<String>> e) -> {
                            return e.getValue().size();
                        }))
                );
        Entry<Integer, List<String>> greatestReversePath = foundReversePath.get();
        System.out.println(greatestReversePath);

        System.out.println("\n===========================================\n");

        System.out.println("Histograms:");
        System.out.println("Normal paths:\n");

        Map<Integer, Integer> pathsHistogram = HistogramUtils.CreateHistogramFromMapBasedOn(paths, List::size);
        HistogramUtils.PrintHistogram(pathsHistogram);
        System.out.println("Reverse paths:\n");

        Map<Integer, Integer> reversePathsHistogram = HistogramUtils.CreateHistogramFromMapBasedOn(reversePaths, List::size);
        HistogramUtils.PrintHistogram(reversePathsHistogram);

        System.out.println("\n===========================================\n");

        System.out.println("Total of paths: " + paths.size());
        System.out.println("Total of reverse paths: " + reversePaths.size());
        System.out.println("");

        int NodeMinusFlow = (hiprOutput.getNodesCount() - 2) / 2 - (int) hiprOutput.getMaxFlow();

        System.out.printf("Path nodes (%d) - Flow(%.1f) = %d\n", (hiprOutput.getNodesCount() - 2) / 2, hiprOutput.getMaxFlow(), NodeMinusFlow);
    }
}
