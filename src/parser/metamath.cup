package parser;
import java_cup.runtime.*;
import Graph.*;
import java.util.*;
import parser.sym.*;

parser code 
{:

/*
 * Variables and structures
 */
private Lexer lexer;
private IGraph graph;
private final Stack<Integer> symStack = new Stack<>();
private final TreeSet<String> foundAssertions = new TreeSet<>();
private final TreeSet<String> foundConstants = new TreeSet<>();
private final TreeSet<String> foundHypothesis = new TreeSet<>();
private String actualTheorem = null;

public parser (Lexer lexer, IGraph graph) { this.lexer = lexer; this.graph = graph; } 

/*
 * Parser helper methods
 */

public void println(Object o) {
    //System.out.println(o);
}

public void pushToStack(Integer symbol){
    symStack.push(symbol);
}

public void verifyStackConsistency(Integer expected) {
    Integer actual = symStack.peek();
    if (!Objects.equals(expected, actual)){
        System.err.println("The parser symbol stack is inconsistent. Exiting the parser...");
        System.exit(1);
    }
}


/*
 * Graph related methods
 */
private void addAxiomNode(String a){
    graph.addNode(a, Label.AXIOM.toString());
}

private void addDefinitionNode(String a){
    graph.addNode(a, Label.DEFINITION.toString());
}

private void addSyntaxDefinitionNode(String a){
    graph.addNode(a, Label.SYNTAX_DEFINITION.toString());
}

private void addTheoremNode(String a){
    graph.addNode(a, Label.THEOREM.toString());
}

private void addHypothesisNode(String h){
    graph.addNode(h, Label.HYPOTHESIS.toString());
}

private void createRelationship(String srcNode, String destNode){
    graph.createRelationship(srcNode, destNode);
}

private void createRelationship(String srcNode, String destNode, String labelName){
    graph.createRelationship(srcNode, destNode, labelName);
}

:}; /* End of 'parser code' section */

/* Preliminaries to set up and use the scanner.  */
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */

terminal            LPARENT, RPARENT;
terminal            SCOPE_START, SCOPE_END;
terminal            INCLUDE_START, INCLUDE_END;
terminal            CONSTANT_STMT, VARIABLE_STMT;
terminal            DISJUNCT_VARIABLE_STMT, VARIABLE_TYPE_HYPOTHESIS_STMT;
terminal            LOGICAL_HYPOTHESIS_STMT, AXIOMATIC_ASSERTION_STMT;
terminal            PROVABLE_ASSERTION_STMT, PROOF_STMT, COMPACT_PROOF,STMT_END;
terminal String     LABEL, MATH_SYMB;

/* Non terminals */

non terminal    initial_symbol, empty;
non terminal    math_symb_list, label_list;
non terminal    const_declaration, var_declaration, disjoint_var_declaration;
non terminal    var_type_hypothesis_declaration, logical_hypothesis_declaration;
non terminal    axiomatic_declaration, theorem_declaration, proof_declaration, proof_labels;
non terminal    include_section, scope_section;

start with initial_symbol;

/* The grammar */

initial_symbol      ::=
                      const_declaration                 initial_symbol
                    | var_declaration                   initial_symbol
                    | disjoint_var_declaration          initial_symbol
                    | var_type_hypothesis_declaration   initial_symbol
                    | logical_hypothesis_declaration    initial_symbol
                    | axiomatic_declaration             initial_symbol
                    | theorem_declaration               initial_symbol
                    | include_section                   initial_symbol
                    | scope_section                     initial_symbol
                    | empty
                    ;

empty               ::=
                    ;

math_symb_list      ::=
                      math_symb_list MATH_SYMB:m
                        {:
                            println("Math symbol found: " + m);
                            switch(symStack.peek()) {
                                case sym.CONSTANT_STMT:
                                    if (!foundConstants.contains(m))
                                        foundConstants.add(m);
                                    else
                                        throw new Exception("Constant redeclaration");
                                    break;
                            }
                        :}
                    | 
                    /*  TODO: Maybe this rule can be replaced by an 'empty' 
                        non-terminal to avoid code repetition */
                      MATH_SYMB:m 
                        {:
                            println("First math symbol found: " + m);
                            switch(symStack.peek()) {
                                case sym.CONSTANT_STMT:
                                    if (!foundConstants.contains(m))
                                        foundConstants.add(m);
                                    else
                                        throw new Exception("Constant redeclaration");
                                    break;
                            }
                        :}
                    ;
 
const_declaration   ::= 
                      CONSTANT_STMT
                        {:
                            println("Constant declaration started");
                            pushToStack(sym.CONSTANT_STMT);
                        :}
                      math_symb_list STMT_END
                        {: 
                            println("Constant declaration finished"); 
                            verifyStackConsistency(sym.CONSTANT_STMT);
                        :}
                    ;

var_declaration     ::= 
                      VARIABLE_STMT
                        {: println("Variable declaration started"); :}
                        {: pushToStack(sym.VARIABLE_STMT); :}
                      math_symb_list STMT_END
                        {: println("Variable declaration finished"); :}
                        {: verifyStackConsistency(sym.VARIABLE_STMT); :}
                    ;

disjoint_var_declaration ::=
                      DISJUNCT_VARIABLE_STMT
                        {: println("Disjunct declaration started"); :}
                        {: pushToStack(sym.DISJUNCT_VARIABLE_STMT); :}
                      MATH_SYMB:m 
                        {: println("Math symbol found: " + m); :}
                      math_symb_list STMT_END
                        {: println("Disjunct declaration finished"); :}
                        {: verifyStackConsistency(sym.DISJUNCT_VARIABLE_STMT); :}
                    ;

/* See Metamath book p. 105 for references */
var_type_hypothesis_declaration ::= /* $f */
                      LABEL:l
                        {:
                            println("variable-type label '" + l + "' found.");
                            foundHypothesis.add(l);
                        :}
                      VARIABLE_TYPE_HYPOTHESIS_STMT
                        {:
                            println("Variable hypothesis declaration started");
                            pushToStack(sym.VARIABLE_TYPE_HYPOTHESIS_STMT);
                        :}
                      MATH_SYMB:constant MATH_SYMB:variable
                        {:
                            if (!foundConstants.contains(constant)) {
                                /* See metamath book p. 105 for details */
                                throw new Exception("Constant '" + constant + "' has not been previously declared");
                            }
                            println("Variable " + variable + " of type " + constant + " found.");
                        :}
                      STMT_END
                        {:
                            println("Variable hypothesis declaration finished");
                            verifyStackConsistency(sym.VARIABLE_TYPE_HYPOTHESIS_STMT);
                        :}
                    ;

logical_hypothesis_declaration ::= /* $e */
                      LABEL:l
                        {:
                            println("logical hypothesis label '" + l + "' found.");
                            foundHypothesis.add(l);
                            addHypothesisNode(l);
                            
                        :}
                      LOGICAL_HYPOTHESIS_STMT
                        {:
                            println("Logical hypothesis declaration started");
                            pushToStack(sym.LOGICAL_HYPOTHESIS_STMT);

                        :}
                      MATH_SYMB:constant
                        {:
                            if (!foundConstants.contains(constant)) {
                            /* See metamath book p. 105 for details */
                                throw new Exception("Constant '" + constant + "' has not been previously declared");
                            }
                        :}
                      math_symb_list
                      STMT_END
                        {:
                            println("Variable hypothesis declaration finished");
                            verifyStackConsistency(sym.LOGICAL_HYPOTHESIS_STMT);

                        :}

                    ;

axiomatic_declaration ::= /* $a */
                      LABEL:l
                        {: 
                            println("label '" + l + "' found."); 
                            if (l.startsWith("ax-")){
                                foundAssertions.add(l);
                                addAxiomNode(l);
                            } else if (l.startsWith("df-")) {
                                foundAssertions.add(l);
                                addDefinitionNode(l);
                            } else {
                                addSyntaxDefinitionNode(l);
                            }
                        :}
                      AXIOMATIC_ASSERTION_STMT
                        {:
                            println("Axiomatic declaration started");
                            pushToStack(sym.AXIOMATIC_ASSERTION_STMT);
                        :}
                      MATH_SYMB:m math_symb_list
                        {: 
                           if (m.equals("|-")){
                               println("Axiom (ax-) or definition (df-) found");
                           } else if (m.equals("wff")){
                               println("Syntax construction found");
                           } else if(m.equals("class")) {
                                println("Syntax construction found for classes");
                           } else {
                                throw new Exception("Unexpected symbol found: " + m);
                           }
                        :}
                      STMT_END
                        {:
                            println("Axiomatic declaration finished");
                            verifyStackConsistency(sym.AXIOMATIC_ASSERTION_STMT);
                        :}
                    ;

theorem_declaration ::=
                      LABEL:l
                        {: 
                            println("label '" + l + "' found.");
                            actualTheorem = l;
                            foundAssertions.add(l);
                            addTheoremNode(l);
                        :}
                      PROVABLE_ASSERTION_STMT /* $p */
                        {:
                            println("Theorem declaration started");
                            pushToStack(sym.PROVABLE_ASSERTION_STMT); /* $p */
                        :}
                      MATH_SYMB:m math_symb_list
                      proof_declaration
                      STMT_END
                        {:
                            println("Theorem declaration finished");
                            verifyStackConsistency(sym.PROVABLE_ASSERTION_STMT); /* $p */
                            actualTheorem = null;

                            
                        :}
                    ;

proof_declaration   ::=
                      PROOF_STMT /* $= */
                        {:
                            println("Proof RPN list");
                        :}
                      label_list
                    | PROOF_STMT /* $= */
                        {:
                            println("Compact proof format");
                        :}
                      LPARENT proof_labels RPARENT COMPACT_PROOF:p
                        {:
                            println("Compact proof found: " + p);
                            
                        :}
                    ;

proof_labels        ::=
                      label_list
                    | empty
                    ;

label_list          ::=
                      label_list LABEL:l
                        {:
                            println("Label found: " + l);
                            if( actualTheorem == null) {
                                throw new Exception("No theorem is being refered actually");
                            }

                            //TODO Treat duplicated cases
                            if (foundAssertions.contains(l)){
                                createRelationship(actualTheorem,l, "RELIES");
                            } else if(foundHypothesis.contains(l)) {
                                createRelationship(actualTheorem, l, "USES");
                            } else {
                                /* We are probably looking to a syntax definition of hypothesis */
                            }
                                
                        :}
                    | LABEL:l
                        {:
                            println("Label found: " + l);
                            if( actualTheorem == null) {
                                throw new Exception("No theorem is being refered actually");
                            }

                            //TODO Treat duplicated cases
                            if (foundAssertions.contains(l)){
                                createRelationship(actualTheorem,l, "RELIES");
                            } else if(foundHypothesis.contains(l)) {
                                createRelationship(actualTheorem, l, "USES");
                            } else {
                                /* We are probably looking to a syntax definition of hypothesis */
                            }
                        :}
                    ;


include_section     ::=
                      INCLUDE_START
                        {: println("Include file section found. Doing nothing"); :}
                      INCLUDE_END
                    ;

scope_section       ::=
                      SCOPE_START
                        {: println("-> New scope found. Doing nothing for now"); :}
                        initial_symbol
                        {: println("<- End of scope found. Doing nothing for now"); :}
                      SCOPE_END
                    ;
